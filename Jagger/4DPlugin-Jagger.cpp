/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Jagger.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Jagger
 #	author : miyako
 #	2025/04/21
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Jagger.h"
#include <string>
#define DEFAULT_DICNAME "ipadic"
#define JAGGER_DEFAULT_MODEL "..\\model\\"
#if VERSIONMAC
#define SEP "/"
#else
#define SEP "\\"
#endif

// Jagger -- C++ implementation of Pattern-based Japanese Morphological Analyzer
//  $Id: jagger.cc 2070 2024-03-14 07:54:57Z ynaga $
// Copyright (c) 2022 Naoki Yoshinaga <ynaga@iis.u-tokyo.ac.jp>
#include <jagger.h>
#include <sstream>
#include <iostream>

#define PIPE_SIZE BUF_SIZE << 4;

#ifndef _WIN32
#define _isatty ::isatty
#define _mmap ::mmap
#define _munmap ::munmap
#define __open ::open
#define __lseek ::lseek
#define _close ::close
#define _pipe pipe
#else
define _pipe(fd) pipe(fd, PIPE_SIZE, _O_BINARY)
#endif


#ifdef _WIN32
#include "getopt.h"
#define PROT_READ    0x1  // Pages can be read
#define PROT_WRITE   0x2  // Pages can be written to
#define PROT_EXEC    0x4  // Pages can be executed
#define PROT_NONE    0x0  // Pages cannot be accessed
#define PAGE_READONLY    0x02
#define PAGE_READWRITE   0x04
#define PAGE_EXECUTE     0x10
#define PAGE_NOACCESS    0x01
#define MAP_SHARED (FILE_MAP_READ | FILE_MAP_WRITE)

void* _mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset) {
    HANDLE hFile = INVALID_HANDLE_VALUE;
    if (fd != -1) {
        hFile = (HANDLE)_get_osfhandle(fd);  // Convert file descriptor to HANDLE
        if (hFile == INVALID_HANDLE_VALUE) return NULL;  // Invalid file handle
    }

    // Open or create file mapping
    HANDLE hMap = CreateFileMapping(hFile,
        NULL,
        PAGE_READWRITE,
        0,
        0,
        NULL);

    if (hMap == NULL) {
        DWORD lastError = GetLastError();
        return NULL;
    }

    // Create a view of the file (map memory)
    void* mappedAddr = MapViewOfFile(hMap,
        FILE_MAP_WRITE,
        0,
        0,
        length);

    if (mappedAddr == NULL) {
        DWORD lastError = GetLastError();
        CloseHandle(hMap);
        return NULL;
    }

    // Return mapped memory address
    return mappedAddr;
}

void _munmap(void* addr, size_t length) {
    UnmapViewOfFile(addr);
}

void utf8_to_wide(const char* utf8_str, std::wstring& utf16_str) {

    if (utf8_str == NULL) {
        return;
    }

    int len = MultiByteToWideChar(CP_UTF8, 0, utf8_str, -1, NULL, 0);
    if (len == 0) {
        return;
    }

    std::vector<unsigned char>buf((len + 1) * sizeof(wchar_t));
    if (MultiByteToWideChar(CP_UTF8,
        0, utf8_str,
        -1,
        (LPWSTR)&buf[0],
        len)) {
        utf16_str = std::wstring((const wchar_t*)&buf[0]);
    }

    return;
}

void wide_to_utf8(const wchar_t* utf16_str, std::string& utf8_str) {

    if (utf16_str == NULL) {
        return;
    }

    int len = WideCharToMultiByte(CP_UTF8, 0, utf16_str, -1, NULL, 0, NULL, NULL);
    if (len == 0) {
        return;
    }

    std::vector<unsigned char>buf((len + 1) * sizeof(char));
    if (WideCharToMultiByte(CP_UTF8,
        0, utf16_str,
        -1,
        (LPSTR)&buf[0],
        len, NULL, NULL)) {
        utf8_str = std::string((const char*)&buf[0]);
    }

    return;
}

int __open(const char* utf8_path, int oflag, ...) {

    std::wstring wide_path;

    utf8_to_wide(utf8_path, wide_path);
    if (wide_path.length() == 0) {
        return -1;  // Conversion failed
    }

    // Use CreateFileW to open the file with the appropriate flags
    HANDLE hFile = CreateFileW(
        wide_path.c_str(),
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        DWORD lastError = GetLastError();
        return -1;  // Return error if CreateFileW fails
    }

    // Convert the file handle to a file descriptor (for compatibility with _open)
    return _open_osfhandle((intptr_t)hFile, 0);  // The second argument 0 indicates no extra flags
}

off_t __lseek(int fd, off_t offset, int whence) {
    // Convert the file descriptor to a Windows HANDLE
    HANDLE hFile = (HANDLE)_get_osfhandle(fd);

    if (hFile == INVALID_HANDLE_VALUE) {
        return -1;  // Invalid file descriptor
    }

    DWORD dwMoveMethod = 0;
    switch (whence) {
    case SEEK_SET:
        dwMoveMethod = FILE_BEGIN;
        break;
    case SEEK_CUR:
        dwMoveMethod = FILE_CURRENT;
        break;
    case SEEK_END:
        dwMoveMethod = FILE_END;
        break;
    default:
        return -1;  // Invalid whence value
    }

    // Move the file pointer to the specified offset
    LARGE_INTEGER liOffset;
    liOffset.QuadPart = offset;

    // Use SetFilePointerEx to set the file pointer
    LARGE_INTEGER liNewPointer;
    if (SetFilePointerEx(hFile, liOffset, &liNewPointer, dwMoveMethod)) {
        return (off_t)liNewPointer.QuadPart;
    }

    // If SetFilePointerEx fails, return -1
    return -1;
}
#endif

namespace jagger {
  class tagger {
  private:
    ccedar::da_  _da;  // there may be cache friendly alignment
    uint16_t*    _c2i; // UTF8 char and BOS -> id
    feat_info_t* _p2f; // pattern id -> feature (info)
    char*        _fs;  // feature strings
    std::vector <std::pair <void*, size_t> > _mmaped;
    void* _read_array (const std::string& fn) {
      int fd = __open(fn.c_str (), O_RDONLY);
        if(fd == -1) {
            std::stringstream ss;
            ss << "no such file: " << fn.c_str ();
            throw std::runtime_error(ss.str());
        }
      const size_t size = __lseek(fd, 0, SEEK_END); // get size
      __lseek(fd, 0, SEEK_SET);
      void *data = _mmap (0, size, PROT_READ, MAP_SHARED, fd, 0);
      _close (fd);
      _mmaped.push_back (std::make_pair (data, size));
      return data;
    }
  public:
    tagger () : _da (), _c2i (0), _p2f (0), _fs (0), _mmaped () {}
    ~tagger () {
      for (size_t i = 0; i < _mmaped.size (); ++i)
        _munmap (_mmaped[i].first, _mmaped[i].second);
    }
    void read_model (const std::string& m) { // read patterns
      _da.set_array (_read_array (m + ".da"));
      _c2i = static_cast <uint16_t*> (_read_array (m + ".c2i"));
      _p2f = static_cast <feat_info_t*> (_read_array (m + ".p2f"));
      _fs  = static_cast <char*> (_read_array (m + ".fs"));
    }
    void write_feature (simple_writer& writer, const bool concat, const feat_info_t finfo) const {
      IF_COMPACT (writer.write (&_fs[finfo.core_feat_offset], finfo.core_feat_len));
      if (concat) { // as unknown words
        IF_NOT_COMPACT (writer.write (&_fs[finfo.feat_offset], finfo.core_feat_len));
        writer.write (",*,*,*\n", 7);
      } else
        writer.write (&_fs[finfo.feat_offset], finfo.feat_len);
    }
    template <const bool TAGGING, const bool TTY>
    void run () const {
      union { struct { uint32_t shift : MAX_PATTERN_BITS, ctype : 4, id : 20; bool concat : 1; }; int r; } s_prev = {}, s = {};
      feat_info_t finfo = { _c2i[CP_MAX + 1] }; // BOS
      simple_reader reader;
      simple_writer writer;
      for (;! reader.eob ();) {
        if ((*reader.ptr () == '\n')) { // EOS
          if (s_prev.r)
            if (TAGGING) write_feature (writer, s_prev.concat, finfo);
          writer.write (TAGGING ? "EOS\n" : "\n", TAGGING ? 4 : 1);
          s.shift = 1;
          s_prev.r = 0; // *
          finfo.ti = _c2i[CP_MAX + 1]; // BOS
          if (TTY) writer.flush (); // line buffering
            if(reader.eob ()) {
                break;
            }
        } else {
          s.r = _da.longestPatternSearch (reader.ptr (), reader.end (), finfo.ti, _c2i);
          if (! s.shift) s.shift = u8_len (reader.ptr ());
          if (s_prev.r &&  // word that may concat with the future context
              ! (s.concat = (s_prev.ctype == s.ctype && // char type mismatch
                             s_prev.ctype != OTHER &&   // kanji, symbol
                             (s_prev.ctype != KANA || s_prev.shift + s.shift < 18)))) {
            if (TAGGING)
              write_feature (writer, s_prev.concat, finfo);
            else
              writer.write (" ", 1);
          }
          finfo = _p2f[s.id];
          s_prev = s; // *
          writer.write (reader.ptr (), s.shift);
        }
        reader.advance (s.shift);
        if (! TTY && ! writer.writable (1 << MAX_FEATURE_BITS)) writer.flush ();
        if (TTY && reader.eob ()) reader.read ();
        if (! TTY && ! reader.readable (1 << MAX_PATTERN_BITS)) reader.read ();
      }
      if (s_prev.r) {
        if (TAGGING) write_feature (writer, s_prev.concat, finfo);
        writer.write (TAGGING ? "EOS\n" : "\n", TAGGING ? 4 : 1);
      }
    }
  };
}

std::string model;
jagger::tagger *tagger = NULL;

static void getResourceDir(std::string &resourcedir) {
    
#if VERSIONMAC
    NSBundle *bundle = [NSBundle bundleWithIdentifier:@"com.4D.Jagger"];
    if(bundle)
    {
        resourcedir = (const char *)[[bundle resourcePath]UTF8String];
    }
    resourcedir += '/';
#else
    wchar_t    fDrive[_MAX_DRIVE], fDir[_MAX_DIR], fName[_MAX_FNAME], fExt[_MAX_EXT];
    wchar_t    bundlePath[_MAX_PATH] = { 0 };

    HMODULE bundle = GetModuleHandleW(L"Jagger.4DX");
    if (bundle) {
        if (GetModuleFileNameW(bundle, bundlePath, _MAX_PATH))
        {
            _wsplitpath_s(bundlePath, fDrive, fDir, fName, fExt);
            std::wstring bundleParentPath = std::wstring(fDrive) + std::wstring(fDir);

            _wsplitpath_s(bundleParentPath.substr(0, bundleParentPath.length()-1).c_str(), fDrive, fDir, fName, fExt);
            std::wstring bundlePath = std::wstring(fDrive) + std::wstring(fDir);

            int len = WideCharToMultiByte(CP_UTF8, 0, bundlePath.c_str(), -1, NULL, 0, NULL, NULL);
            if (len) {
                std::vector<uint8_t> buf(len);
                if (WideCharToMultiByte(CP_UTF8, 0, bundlePath.c_str(), bundlePath.size(), (LPSTR)&buf[0], len, NULL, NULL)) {
                    resourcedir =  std::string((const char *)&buf[0]) + "Resources";
                }
            }
        }
    }
    resourcedir += '\\';
#endif
}

static void getDefaultModel(std::string &defaultmodel) {
    
    getResourceDir(defaultmodel);
    
    defaultmodel += ("model" SEP "kyoto+kwdlc" SEP);
}

#pragma mark -

static jagger::tagger *read_model(std::string path) {
  
    jagger::tagger *_tagger = new jagger::tagger();
    try {
        _tagger->read_model(path + "patterns");
        model = path;
        if(tagger != NULL) {
            delete tagger;
        }
        return _tagger;
    }catch (const std::runtime_error& e) {
        delete _tagger;
    }
    
    return tagger;
}

static void onStartup() {
    
    getDefaultModel(model);
    tagger = read_model(model);
}

static void onExit() {
    
    if(tagger != NULL) {
        delete tagger;
        tagger = NULL;
    }
}

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
                onStartup();
                break;
             
            case kDeinitPlugin :
            case kServerDeinitPlugin :
                onExit();
                break;
                
			// --- Jagger
            
			case 1 :
				Jagger_split(params);
				break;
			case 2 :
				Jagger_tokenize(params);
				break;
			case 3 :
				Jagger_train(params);
				break;
            case 4 :
                Jagger_set_model(params);
                break;
            case 5 :
                Jagger_get_model(params);
                break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

static bool folder_object_to_path(PA_ObjectRef f, std::string& path) {
 
    if(f != NULL) {
        C_TEXT pp;
        pp.setUTF8String((const uint8_t *)"platformPath", 12);
        PA_Unistring PLATFORMPATH = PA_CreateUnistring((PA_Unichar *)pp.getUTF16StringPtr());
        
        if(PA_GetObjectPropertyType(f, &PLATFORMPATH) == eVK_Unistring) {
            
            PA_Variable p = PA_GetObjectProperty(f, &PLATFORMPATH);
            PA_Variable    cbparams[2];
            cbparams[0] = PA_CreateVariable(eVK_Unistring);
            cbparams[1] = PA_CreateVariable(eVK_Longint);
            PA_Unistring platformPath = PA_GetStringVariable(p);
            PA_SetStringVariable(&cbparams[0], &platformPath);
            PA_SetLongintVariable(&cbparams[1], 1/*fk platform path*/);
            PA_Variable folder = PA_ExecuteCommandByID(1567 /*4D.Folder*/, cbparams, 2);
            
#if VERSIONMAC
            pp.setUTF8String((const uint8_t *)"path", 4);
            PA_Unistring PATH = PA_CreateUnistring((PA_Unichar *)pp.getUTF16StringPtr());
            PA_Variable _p = PA_GetObjectProperty(PA_GetObjectVariable(folder), &PATH);
            platformPath = PA_GetStringVariable(_p);
#endif
            C_TEXT t;
            t.setUTF16String(&platformPath);
            CUTF8String u8;
            t.copyUTF8String(&u8);
            path = (const char *)u8.c_str();
            
            PA_ClearVariable(&cbparams[0]);
            PA_ClearVariable(&cbparams[1]);//PLATFORMPATH belongs to variable. no need to dispose
#if VERSIONMAC
            PA_DisposeUnistring(&PATH);
            PA_ClearVariable(&_p);//see .h of PA_GetObjectProperty
#endif
            PA_ClearVariable(&p);//see .h of PA_GetObjectProperty
            
            return true;
        }
    
    }
    
    return false;
}

static PA_ObjectRef path_to_folder_object(std::string& m) {
    
    PA_Variable    cbparams[2];
    cbparams[0] = PA_CreateVariable(eVK_Unistring);
    cbparams[1] = PA_CreateVariable(eVK_Longint);
    
    C_TEXT t;
    t.setUTF8String((const uint8_t *)m.c_str(), (uint32_t)m.length());
    PA_Unistring path = PA_CreateUnistring((PA_Unichar *)t.getUTF16StringPtr());
    
    PA_SetStringVariable(&cbparams[0], &path);
    PA_SetLongintVariable(&cbparams[1], 1/*fk platform path*/);
    PA_Variable folder = PA_ExecuteCommandByID(1567 /*4D.Folder*/, cbparams, 2);
    PA_ClearVariable(&cbparams[0]);
    PA_ClearVariable(&cbparams[1]);//path belongs to variable. no need to dispose

    return PA_GetObjectVariable(folder);
}

void Jagger_get_model(PA_PluginParameters params) {

    PA_ReturnObject(params, path_to_folder_object(model));
}

void Jagger_set_model(PA_PluginParameters params) {

    std::string path;
    if(folder_object_to_path(PA_GetObjectParameter(params, 1), path)) {
        tagger = read_model(path);
    }
    PA_ReturnObject(params, path_to_folder_object(model));
}

static void _Jagger(PA_PluginParameters params, bool tagging) {
    
    C_TEXT t;
    
    if(tagger != NULL) {
        PA_Unistring *u16 = PA_GetStringParameter(params, 1);
        t.setUTF16String(u16);
        CUTF8String u8;
        t.copyUTF8String(&u8);
        
        // --- Redirect stdin ---
            int stdin_pipe[2];
        
            _pipe(stdin_pipe);
            write(stdin_pipe[1], u8.c_str(), u8.size());
            close(stdin_pipe[1]);  // simulate EOF

            int saved_stdin = dup(0);
            dup2(stdin_pipe[0], 0);
            close(stdin_pipe[0]);

            // --- Redirect stdout ---
            int stdout_pipe[2];
            _pipe(stdout_pipe);
            int saved_stdout = dup(1);
            dup2(stdout_pipe[1], 1);
            close(stdout_pipe[1]);
        
        if (tagging) tagger->run <true, true>  (); else tagger->run <false, true>  ();

        // --- Restore stdout and stdin ---
            fflush(stdout);
            std::cout.flush();

            dup2(saved_stdout, 1);
            close(saved_stdout);

            dup2(saved_stdin, 0);
            close(saved_stdin);

        // --- Read from captured stdout pipe ---
           std::ostringstream output;
           char ch;
           while (read(stdout_pipe[0], &ch, 1) > 0) {
               output << ch;
           }
           close(stdout_pipe[0]);
        
        t.setUTF8String((const uint8_t *)output.str().c_str(), (uint32_t)output.str().length());
    }
    
    PA_ReturnString(params, (PA_Unichar *)t.getUTF16StringPtr());
}

void Jagger_split(PA_PluginParameters params) {

    _Jagger(params, false);
}

void Jagger_tokenize(PA_PluginParameters params) {

    _Jagger(params, true);
}

void Jagger_train(PA_PluginParameters params) {

}

